<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sub Bridge</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
</head>
<body class="min-h-screen bg-neutral-950 text-neutral-100 antialiased">
  <main class="mx-auto flex w-full max-w-xl flex-col gap-4 px-5 py-6" x-data="app()">

    <!-- SVG Icons -->
    <svg class="hidden" aria-hidden="true">
      <symbol id="logo-claude" viewBox="0 0 24 24">
        <path fill="currentColor" d="m4.7144 15.9555 4.7174-2.6471.079-.2307-.079-.1275h-.2307l-.7893-.0486-2.6956-.0729-2.3375-.0971-2.2646-.1214-.5707-.1215-.5343-.7042.0546-.3522.4797-.3218.686.0608 1.5179.1032 2.2767.1578 1.6514.0972 2.4468.255h.3886l.0546-.1579-.1336-.0971-.1032-.0972L6.973 9.8356l-2.55-1.6879-1.3356-.9714-.7225-.4918-.3643-.4614-.1578-1.0078.6557-.7225.8803.0607.2246.0607.8925.686 1.9064 1.4754 2.4893 1.8336.3643.3035.1457-.1032.0182-.0728-.164-.2733-1.3539-2.4467-1.445-2.4893-.6435-1.032-.17-.6194c-.0607-.255-.1032-.4674-.1032-.7285L6.287.1335 6.6997 0l.9957.1336.419.3642.6192 1.4147 1.0018 2.2282 1.5543 3.0296.4553.8985.2429.8318.091.255h.1579v-.1457l.1275-1.706.2368-2.0947.2307-2.6957.0789-.7589.3764-.9107.7468-.4918.5828.2793.4797.686-.0668.4433-.2853 1.8517-.5586 2.9021-.3643 1.9429h.2125l.2429-.2429.9835-1.3053 1.6514-2.0643.7286-.8196.85-.9046.5464-.4311h1.0321l.759 1.1293-.34 1.1657-1.0625 1.3478-.8804 1.1414-1.2628 1.7-.7893 1.36.0729.1093.1882-.0183 2.8535-.607 1.5421-.2794 1.8396-.3157.8318.3886.091.3946-.3278.8075-1.967.4857-2.3072.4614-3.4364.8136-.0425.0304.0486.0607 1.5482.1457.6618.0364h1.621l3.0175.2247.7892.522.4736.6376-.079.4857-1.2142.6193-1.6393-.3886-3.825-.9107-1.3113-.3279h-.1822v.1093l1.0929 1.0686 2.0035 1.8092 2.5075 2.3314.1275.5768-.3218.4554-.34-.0486-2.2039-1.6575-.85-.7468-1.9246-1.621h-.1275v.17l.4432.6496 2.3436 3.5214.1214 1.0807-.17.3521-.6071.2125-.6679-.1214-1.3721-1.9246L14.38 17.959l-1.1414-1.9428-.1397.079-.674 7.2552-.3156.3703-.7286.2793-.6071-.4614-.3218-.7468.3218-1.4753.3886-1.9246.3157-1.53.2853-1.9004.17-.6314-.0121-.0425-.1397.0182-1.4328 1.9672-2.1796 2.9446-1.7243 1.8456-.4128.164-.7164-.3704.0667-.6618.4008-.5889 2.386-3.0357 1.4389-1.882.929-1.0868-.0062-.1579h-.0546l-6.3385 4.1164-1.1293.1457-.4857-.4554.0608-.7467.2307-.2429 1.9064-1.3114Z"/>
      </symbol>
      <symbol id="logo-openai" viewBox="0 0 24 24">
        <path fill="currentColor" d="M22.2819 9.8211a5.9847 5.9847 0 0 0-.5157-4.9108 6.0462 6.0462 0 0 0-6.5098-2.9A6.0651 6.0651 0 0 0 4.9807 4.1818a5.9847 5.9847 0 0 0-3.9977 2.9 6.0462 6.0462 0 0 0 .7427 7.0966 5.98 5.98 0 0 0 .511 4.9107 6.051 6.051 0 0 0 6.5146 2.9001A5.9847 5.9847 0 0 0 13.2599 24a6.0557 6.0557 0 0 0 5.7718-4.2058 5.9894 5.9894 0 0 0 3.9977-2.9001 6.0557 6.0557 0 0 0-.7475-7.0729zm-9.022 12.6081a4.4755 4.4755 0 0 1-2.8764-1.0408l.1419-.0804 4.7783-2.7582a.7948.7948 0 0 0 .3927-.6813v-6.7369l2.02 1.1686a.071.071 0 0 1 .038.052v5.5826a4.504 4.504 0 0 1-4.4945 4.4944zm-9.6607-4.1254a4.4708 4.4708 0 0 1-.5346-3.0137l.142.0852 4.783 2.7582a.7712.7712 0 0 0 .7806 0l5.8428-3.3685v2.3324a.0804.0804 0 0 1-.0332.0615L9.74 19.9502a4.4992 4.4992 0 0 1-6.1408-1.6464zM2.3408 7.8956a4.485 4.485 0 0 1 2.3655-1.9728V11.6a.7664.7664 0 0 0 .3879.6765l5.8144 3.3543-2.0201 1.1685a.0757.0757 0 0 1-.071 0l-4.8303-2.7865A4.504 4.504 0 0 1 2.3408 7.872zm16.5963 3.8558L13.1038 8.364 15.1192 7.2a.0757.0757 0 0 1 .071 0l4.8303 2.7913a4.4944 4.4944 0 0 1-.6765 8.1042v-5.6772a.79.79 0 0 0-.407-.667zm2.0107-3.0231l-.142-.0852-4.7735-2.7818a.7759.7759 0 0 0-.7854 0L9.409 9.2297V6.8974a.0662.0662 0 0 1 .0284-.0615l4.8303-2.7866a4.4992 4.4992 0 0 1 6.6802 4.66zM8.3065 12.863l-2.02-1.1638a.0804.0804 0 0 1-.038-.0567V6.0742a4.4992 4.4992 0 0 1 7.3757-3.4537l-.142.0805L8.704 5.459a.7948.7948 0 0 0-.3927.6813zm1.0976-2.3654l2.602-1.4998 2.6069 1.4998v2.9994l-2.5974 1.4997-2.6067-1.4997Z"/>
      </symbol>
    </svg>

    <!-- OAuth Flow Banner -->
    <template x-if="oauth.active">
      <div class="rounded-xl border border-sky-500/30 bg-sky-950/50 p-4 shadow-sm">
        <div class="flex items-center justify-between">
          <div class="flex items-center gap-3">
            <div class="flex h-8 w-8 items-center justify-center rounded-full bg-sky-500/20">
              <svg class="h-4 w-4 text-sky-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"/>
              </svg>
            </div>
            <div>
              <p class="text-sm font-medium text-sky-100">Authorizing MCP Client</p>
              <p class="text-xs text-sky-300/70" x-text="'Client: ' + (oauth.clientId || 'Unknown')"></p>
            </div>
          </div>
          <div class="flex items-center gap-2">
            <template x-if="(claude.connected || chatgpt.connected) && !oauth.completing">
              <button
                @click="completeOAuthFlow()"
                class="rounded-lg bg-sky-500 px-4 py-2 text-sm font-semibold text-white hover:bg-sky-400 transition"
              >
                Authorize
              </button>
            </template>
            <template x-if="oauth.completing">
              <span class="text-sm text-sky-300">Completing...</span>
            </template>
          </div>
        </div>
        <template x-if="oauth.error">
          <p class="mt-2 text-sm text-red-400" x-text="oauth.error"></p>
        </template>
        <template x-if="!claude.connected && !chatgpt.connected">
          <p class="mt-2 text-xs text-sky-300/70">Please login with Claude or ChatGPT below to authorize.</p>
        </template>
      </div>
    </template>

    <!-- Connect Section -->
    <div class="flex items-center justify-between">
      <h2 class="text-xs font-semibold uppercase tracking-wider text-neutral-400">Providers</h2>
      <a class="text-[10px] text-neutral-500 hover:text-neutral-300">Your credentials are only stored in your browser</a>
    </div>
    <section class="rounded-xl border border-neutral-800 bg-neutral-900/70 p-4 shadow-sm">
      <div class="flex flex-col gap-3">

        <!-- Claude Row -->
        <div class="flex flex-col gap-1">
          <div class="flex items-center gap-3 flex-wrap">
            <!-- Button -->
            <template x-if="!claude.showInput">
              <a
                @click.prevent="claude.showInput = true; window.open('/auth/claude', '_blank')"
                href="/auth/claude"
                class="group inline-flex items-center justify-center gap-2 rounded-lg bg-[#d97757] px-3 py-2 text-sm font-semibold text-white shadow-sm transition hover:bg-[#c4674b] cursor-pointer"
              >
                <svg class="h-4 w-4 text-white" viewBox="0 0 24 24" aria-hidden="true"><use href="#logo-claude"></use></svg>
                <span>Login with Claude</span>
              </a>
            </template>
            <template x-if="claude.showInput">
              <button
                disabled
                class="group inline-flex items-center justify-center gap-2 rounded-lg bg-[#d97757] px-3 py-2 text-sm font-semibold text-white shadow-sm transition disabled:opacity-50 shrink-0"
              >
                <svg class="h-4 w-4 text-white" viewBox="0 0 24 24" aria-hidden="true"><use href="#logo-claude"></use></svg>
                <span>Login with Claude</span>
              </button>
            </template>
            <!-- Input (shown after first click) -->
            <template x-if="claude.showInput">
              <div class="flex items-center gap-2 flex-1">
                <span class="text-xs text-neutral-400 shrink-0">Enter code</span>
                <input
                  type="text"
                  x-model="claude.code"
                  @input="claudeCodeInput()"
                  placeholder="CODE#STATE"
                  class="flex-1 rounded-lg border border-neutral-800 bg-neutral-950 px-3 py-2 text-sm text-neutral-100 placeholder:text-neutral-500 focus:border-neutral-600 focus:outline-none font-mono"
                  :disabled="claude.loading"
                  x-init="$nextTick(() => $el.focus())"
                >
                <template x-if="claude.loading">
                  <span class="text-xs text-neutral-400 shrink-0">Checking...</span>
                </template>
              </div>
            </template>
          </div>
          <!-- Status Indicator -->
          <div class="flex items-center gap-2 text-xs">
            <span class="h-2 w-2 rounded-full" :class="claude.connected ? 'bg-emerald-400' : 'bg-neutral-600'"></span>
            <span class="text-xs" :class="claude.connected ? 'text-emerald-400' : 'text-neutral-500'" x-text="claude.connected ? 'Connected' : 'Not connected'"></span>
            <!-- Account Switcher (show when multiple accounts) -->
            <template x-if="Object.keys(claude.accounts).length > 1">
              <select
                x-model="claude.activeAccount"
                @change="localStorage.setItem('claude_active_account', claude.activeAccount)"
                class="ml-2 rounded border border-neutral-700 bg-neutral-900 px-2 py-1 text-xs text-neutral-200 focus:border-neutral-600 focus:outline-none"
              >
                <template x-for="email in Object.keys(claude.accounts)" :key="email">
                  <option :value="email" x-text="claude.accounts[email].displayName || email"></option>
                </template>
              </select>
            </template>
            <template x-if="claude.connected">
              <button
                @click="disconnectClaude()"
                class="ml-1 text-xs text-neutral-400 hover:text-red-400 transition"
                title="Disconnect and clear token"
              >
                <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
              </button>
            </template>
          </div>
        </div>
        <!-- Claude Error -->
        <template x-if="claude.error">
          <p class="text-sm text-red-400" x-text="claude.error"></p>
        </template>

        <!-- ChatGPT Row -->
        <div class="flex flex-col gap-1">
          <div class="flex items-center gap-3 flex-wrap">
            <!-- Button -->
            <button
              @click="if(!chatgpt.showInput) { startChatGPT(); window.open('https://auth.openai.com/codex/device', '_blank'); } chatgpt.showInput = true"
            :disabled="chatgpt.polling || chatgpt.showInput"
            class="group inline-flex items-center justify-center gap-2 rounded-lg bg-[#10a37f] px-3 py-2 text-sm font-semibold text-white shadow-sm transition hover:bg-[#0d8a6a] disabled:opacity-50 shrink-0"
          >
            <svg class="h-4 w-4 text-white" viewBox="0 0 24 24" aria-hidden="true"><use href="#logo-openai"></use></svg>
            <span>Login with ChatGPT</span>
          </button>
          <!-- Login link + Input (shown after first click) -->
          <template x-if="chatgpt.showInput">
            <div class="flex items-center gap-2">
              <span class="text-xs text-neutral-400 shrink-0">Enter device id</span>
              <input
                type="text"
                :value="chatgpt.deviceId"
                  readonly
                  @focus="$el.select()"
                  class="w-32 rounded-lg border border-neutral-800 bg-neutral-950 px-3 py-2 text-sm text-neutral-100 font-mono text-center"
                >
              <template x-if="chatgpt.polling">
                <span class="text-xs text-neutral-400 shrink-0">Checking...</span>
              </template>
              </div>
            </template>
          </div>
          <!-- Status Indicator -->
          <div class="flex items-center gap-2 text-xs">
            <span class="h-2 w-2 rounded-full" :class="chatgpt.connected ? 'bg-emerald-400' : 'bg-neutral-600'"></span>
            <span class="text-xs" :class="chatgpt.connected ? 'text-emerald-400' : 'text-neutral-500'" x-text="chatgpt.connected ? 'Connected' : 'Not connected'"></span>
            <!-- Account Switcher (show when multiple accounts) -->
            <template x-if="Object.keys(chatgpt.accounts).length > 1">
              <select
                x-model="chatgpt.activeAccount"
                @change="localStorage.setItem('chatgpt_active_account', chatgpt.activeAccount)"
                class="ml-2 rounded border border-neutral-700 bg-neutral-900 px-2 py-1 text-xs text-neutral-200 focus:border-neutral-600 focus:outline-none"
              >
                <template x-for="accountId in Object.keys(chatgpt.accounts)" :key="accountId">
                  <option :value="accountId" x-text="chatgpt.accounts[accountId].displayName || accountId"></option>
                </template>
              </select>
            </template>
            <template x-if="chatgpt.connected">
              <button
                @click="disconnectChatGPT()"
                class="ml-1 text-xs text-neutral-400 hover:text-red-400 transition"
                title="Disconnect and clear token"
              >
                <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
              </button>
            </template>
          </div>
        </div>
        <!-- ChatGPT Error -->
        <template x-if="chatgpt.error">
          <p class="text-sm text-red-400" x-text="chatgpt.error"></p>
        </template>

      </div>
    </section>

   

    <!-- Datalists for autocomplete -->
    <datalist id="cursor-models">
      <option value="o3">
      <option value="o3-mini">
      <option value="gpt-4o">
      <option value="gpt-4o-mini">
    </datalist>
    <datalist id="claude-models">
      <option value="opus-4.5">
      <option value="sonnet-4.5">
      <option value="haiku">
    </datalist>

    <!-- ============================================================ -->
    <!-- DEFAULT VIEW: API Key + Tunnel (when no target app) -->
    <!-- ============================================================ -->
      <div class="space-y-4" x-init="fetchTunnelProviders()">
        <section class="space-y-2">
          <h2 class="text-xs font-semibold uppercase tracking-wider text-neutral-400">OpenAI API Gateway</h2>
          <div class="rounded-xl border border-neutral-800 bg-neutral-900/70 shadow-sm">
            <div class="flex flex-col gap-4 p-4">
              <div class="flex items-center justify-between">
                <div class="flex items-center gap-2">
                  <span
                    class="h-2 w-2 rounded-full"
                    :class="tunnel.loading ? 'bg-neutral-500 animate-pulse' : (tunnel.status.active || hasExternalUrl ? 'bg-emerald-400' : 'bg-neutral-600')"
                  ></span>
                  <span
                    class="text-xs"
                    :class="tunnel.loading ? 'text-neutral-400' : (tunnel.status.active || hasExternalUrl ? 'text-emerald-400' : 'text-neutral-500')"
                    x-text="tunnel.loading ? 'Loading' : (tunnel.status.active ? 'Connected' : (hasExternalUrl ? 'External URL' : 'Inactive'))"
                  ></span>
                </div>
                <template x-if="tunnel.status.active">
                  <button
                    @click="stopTunnel()"
                    class="rounded-lg border border-red-500/60 px-3 py-1.5 text-xs font-semibold text-red-200 hover:bg-red-500/20"
                  >Stop Tunnel</button>
                </template>
              </div>

              <div class="space-y-1">
                <label
                  class="text-[10px] font-semibold uppercase tracking-wider text-neutral-500"
                  x-text="tunnelLabel"
                ></label>
                <input
                  type="text"
                  :value="hasTunnel ? effectivePublicUrl + '/v1' : tunnel.customDomain"
                  :readonly="hasTunnel"
                  @input="if (!hasTunnel) tunnel.customDomain = $event.target.value"
                  @focus="$el.select()"
                  :placeholder="hasTunnel ? '' : (tunnel.loading ? 'Loading providers...' : 'e.g. yourname.example.com')"
                  class="w-full rounded-lg border border-neutral-800 bg-neutral-950 px-3 py-2 text-sm text-neutral-100 placeholder:text-neutral-600 focus:border-neutral-600 focus:outline-none font-mono"
                >
              </div>

              <template x-if="!hasTunnel">
                <div class="space-y-3">
                  <div class="flex flex-wrap items-center justify-between gap-3">
                    <div class="flex flex-wrap gap-2" x-show="!tunnel.loading && tunnel.providers.some(p => p.available)">
                      <template x-for="p in tunnel.providers.filter(p => p.available)" :key="p.id">
                        <button
                          @click="tunnel.selectedProvider = p.id"
                          :class="tunnel.selectedProvider === p.id ? 'bg-neutral-700 text-white border-neutral-600' : 'bg-neutral-950 text-neutral-400 border-neutral-800'"
                          class="inline-flex items-center justify-center rounded-lg border px-3 py-1.5 text-xs font-semibold uppercase tracking-wide transition"
                          x-text="p.name"
                        ></button>
                      </template>
                    </div>
                    <div class="flex flex-wrap gap-2" x-show="tunnel.loading">
                      <span class="h-7 w-20 rounded-lg border border-neutral-800 bg-neutral-900/60 animate-pulse"></span>
                      <span class="h-7 w-16 rounded-lg border border-neutral-800 bg-neutral-900/60 animate-pulse"></span>
                      <span class="h-7 w-12 rounded-lg border border-neutral-800 bg-neutral-900/60 animate-pulse"></span>
                    </div>
                    <template x-if="!tunnel.status.active && !hasExternalUrl">
                      <button
                        @click="startTunnel()"
                        :disabled="tunnel.starting || !tunnel.selectedProvider || !tunnel.providers.some(p => p.available)"
                        class="rounded-lg bg-neutral-100 px-3 py-2 text-xs font-semibold text-neutral-950 hover:bg-white disabled:opacity-50"
                        x-text="tunnel.starting ? 'Creating...' : 'Create Tunnel'"
                        x-show="!tunnel.loading"
                      ></button>
                    </template>
                  </div>
                  <p x-show="!tunnel.providers.some(p => p.available) && !tunnel.loading" class="text-xs text-neutral-400">
                    No tunnel providers found (install cloudflared, ngrok, or tailscale).
                  </p>
                </div>
              </template>

              <p x-show="tunnel.error" class="text-xs text-red-400" x-text="tunnel.error"></p>
            </div>

            <div class="space-y-1 px-4 pb-4">
              <label class="text-[10px] font-semibold uppercase tracking-wider text-neutral-500">Generated API Key</label>
              <input
                type="text"
                :value="apiKey"
                readonly
                @focus="$el.select()"
                placeholder="Connect to a provider first..."
                class="w-full rounded-lg border border-neutral-800 bg-neutral-950 px-3 py-2 text-sm text-neutral-100 focus:border-neutral-600 focus:outline-none font-mono"
              >
            </div>
              
            <template x-if="claude.connected || chatgpt.connected">
              <div class="flex items-center gap-3 p-4 border-t border-neutral-800">
              <div class="flex items-start gap-3">
                <div class="flex flex-col gap-2 w-full">
                  <template x-for="(route, i) in routes" :key="i">
                    <div
                      class="grid items-center gap-2"
                      :class="Object.keys(claude.accounts).length > 1 ? 'grid-cols-[1fr_auto_auto_1fr_auto]' : 'grid-cols-[1fr_auto_1fr_auto]'"
                    >
                      <input
                        type="text"
                        list="cursor-models"
                        x-model="route.cursor"
                        placeholder="Cursor model..."
                        class="w-full rounded-lg border border-neutral-800 bg-neutral-950 px-3 py-2 text-sm text-neutral-100 placeholder:text-neutral-500 focus:border-neutral-600 focus:outline-none"
                      >
                      <span class="text-neutral-500 px-1">-></span>
                      <template x-if="Object.keys(claude.accounts).length > 1">
                        <select
                          x-model="route.account"
                          x-init="route.account = route.account || claude.activeAccount"
                          class="rounded-lg border border-neutral-800 bg-neutral-950 px-2 py-2 text-sm text-neutral-100 focus:border-neutral-600 focus:outline-none"
                        >
                          <template x-for="email in Object.keys(claude.accounts)" :key="'route-account-' + email">
                            <option :value="email" x-text="claude.accounts[email].displayName || email"></option>
                          </template>
                        </select>
                      </template>
                      <input
                        type="text"
                        list="claude-models"
                        x-model="route.claude"
                        placeholder="Claude model..."
                        class="w-full rounded-lg border border-neutral-800 bg-neutral-950 px-3 py-2 text-sm text-neutral-100 placeholder:text-neutral-500 focus:border-neutral-600 focus:outline-none"
                      >
                      <button
                        @click="routes.splice(i, 1)"
                        class="p-2 text-neutral-500 hover:text-red-400 transition"
                        title="Remove route"
                      >
                        <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/></svg>
                      </button>
                    </div>
                  </template>
                  <button
                    @click="routes.push({ cursor: '', claude: '', account: claude.activeAccount || '' })"
                    class="inline-flex items-center gap-1 text-sm text-neutral-400 hover:text-neutral-200 transition mt-1"
                  >
                    <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/></svg>
                    Add Route
                  </button>
                </div>
                <label class="text-xs text-neutral-500 shrink-0 w-28 text-right self-start">Routes</label>
              </div>
              </div>
            </template>
          </div>
        </section>   
            <!-- Integrate Section -->
            <section class="space-y-2">
              <h2 class="text-xs font-semibold uppercase tracking-wider text-neutral-400">Integrations</h2>
              <div class="rounded-xl border border-neutral-800 bg-neutral-900/70 shadow-sm overflow-hidden">
                
                <!-- Tabs -->
                <div class="flex flex-wrap gap-2 p-4" :class="{'border-b border-neutral-800': targetApp}">
                  <button
                    @click="setTargetApp('cursor')"
                    :class="targetApp === 'cursor' ? 'bg-neutral-100 text-neutral-950' : 'bg-neutral-800 text-neutral-200 border border-neutral-700 hover:bg-neutral-700'"
                    class="inline-flex items-center gap-2 rounded-lg px-3 py-2 text-sm font-medium transition"
                  >
                    <svg class="h-4 w-4" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg>
                    Cursor
                  </button>
                  <!-- Add more integrations here -->
                </div>
        
                <!-- Cursor Setup Instructions -->
                <div x-show="targetApp === 'cursor'" class="p-4 bg-neutral-900/30">
                  <ol class="space-y-2 text-sm text-neutral-200">
                    <li class="flex items-start gap-2"><span class="mt-0.5 flex h-5 w-5 items-center justify-center rounded-full bg-neutral-800 text-[11px]">1</span><span>Open Cursor Settings -> Models -> API Keys</span></li>
                    <li class="flex items-start gap-2"><span class="mt-0.5 flex h-5 w-5 items-center justify-center rounded-full bg-neutral-800 text-[11px]">2</span><span>Enable "OpenAI API Key" toggle</span></li>
                    <li class="flex flex-col gap-1">
                      <div class="flex items-center gap-2">
                        <span class="mt-0.5 flex h-5 w-5 items-center justify-center rounded-full bg-neutral-800 text-[11px]">3</span>
                        <div class="flex-1 space-y-1">
                          <div class="relative w-full">
                            <span class="absolute left-3 top-1/2 -translate-y-1/2 text-neutral-500 text-xs pr-1">Set API Key:</span>
                            <input
                              type="text"
                              :value="apiKey"
                              readonly
                              @focus="$el.select()"
                              placeholder="Connect to a provider first..."
                              class="w-full rounded-lg border border-neutral-800 bg-neutral-950 px-3 py-2 text-xs text-neutral-100 focus:border-neutral-600 focus:outline-none font-mono pl-[95px]"
                            >
                          </div>
                        </div>
                      </div>
                    </li>
                    <li class="flex items-start gap-2"><span class="mt-0.5 flex h-5 w-5 items-center justify-center rounded-full bg-neutral-800 text-[11px]">4</span><span>Enable "Override OpenAI Base URL"</span></li>
                    <li class="flex flex-col gap-1">
                      <div class="flex items-start gap-2">
                        <span class="mt-0.5 flex h-5 w-5 items-center justify-center rounded-full bg-neutral-800 text-[11px] shrink-0">5</span>
                        <div class="flex-1 space-y-1">
                          <div class="relative w-full">
                            <span class="absolute left-3 top-1/2 -translate-y-1/2 text-neutral-500 text-xs pr-1">Set Base URL:</span>
                            <input
                              type="text"
                              :value="hasTunnel ? effectivePublicUrl + '/v1' : ''"
                              readonly
                              @focus="$el.select()"
                              :placeholder="hasTunnel ? '' : 'Create a tunnel first...'"
                              class="rounded-lg border border-neutral-800 bg-neutral-950 px-3 py-2 text-xs text-neutral-100 focus:border-neutral-600 focus:outline-none font-mono pl-[100px] w-full"
                            >
                          </div>
                        </div>
                      </div>
                    </li>
                    <li class="flex items-start gap-2">
                      <span class="mt-0.5 flex h-5 w-5 items-center justify-center rounded-full bg-neutral-800 text-[11px]">6</span>
                      <span>
                        <template x-if="claude.connected && routes.length > 0 && routes[0].cursor && routes[0].claude">
                          <span>Select <code class="rounded bg-neutral-800/80 px-1.5 py-0.5 text-xs" x-text="routes[0].cursor"></code> model in Cursor agent to connect <code class="rounded bg-neutral-800/80 px-1.5 py-0.5 text-xs" x-text="routes[0].claude"></code></span>
                        </template>
                        <template x-if="!claude.connected || !routes.length || !routes[0].cursor || !routes[0].claude">
                          <span>Select an OpenAI model in Cursor agent</span>
                        </template>
                      </span>
                    </li>
                  </ol>
                </div>
              </div>
            </section>
          </div>
  </main>

  <script>
    function app() {
      return {
        // Auth state
        claude: {
          accounts: {},         // Map of email -> account data
          activeAccount: null,  // Currently active email
          connected: false,
          code: '',
          loading: false,
          error: null,
          showInput: false
        },
        chatgpt: {
          accounts: {},         // Map of accountId -> account data
          activeAccount: null,  // Currently active accountId
          connected: false,
          deviceId: '',
          sessionId: null,
          polling: false,
          error: null,
          showInput: false
        },

        // Routing state
        routes: [
          { cursor: 'o3', claude: 'opus-4.5', account: '' },
          { cursor: 'o3-mini', claude: 'sonnet-4.5', account: '' }
        ],

        // Tunnel state
        tunnel: {
          showPanel: false,
          providers: [],
          selectedProvider: null,
          status: { active: false, publicUrl: null },
          loading: false,
          starting: false,
          error: null,
          customDomain: ''
        },

        // Server config
        publicUrl: window.location.origin,
        port: '',

        // Target app from ?to= query parameter (cursor, etc.)
        targetApp: new URLSearchParams(window.location.search).get('to') || '',

        // OAuth flow state (for MCP client authorization)
        oauth: {
          active: false,
          pendingId: null,
          clientId: null,
          state: null,
          error: null,
          completing: false
        },

        // Check if we have an external URL (pre-configured tunnel via --tunnel flag)
        get hasExternalUrl() {
          return this.publicUrl.startsWith('https://') && !this.publicUrl.includes('localhost');
        },

        // Effective public URL (dynamic tunnel takes precedence, then pre-configured)
        get effectivePublicUrl() {
          return this.tunnel.status.active ? this.tunnel.status.publicUrl : this.publicUrl;
        },

        // Whether we have any tunnel (dynamic or pre-configured)
        get hasTunnel() {
          return this.tunnel.status.active || this.hasExternalUrl;
        },

        // Selected tunnel provider name (falls back to generic label)
        get selectedTunnelName() {
          const selected = this.tunnel.providers.find(p => p.id === this.tunnel.selectedProvider);
          return selected ? selected.name : 'Tunnel';
        },

        // Label text for the tunnel/domain input
        get tunnelLabel() {
          if (this.hasTunnel) {
            return 'OpenAI Base URL';
          }
          if (!this.tunnel.selectedProvider) {
            return 'Select a tunnel provider';
          }
          const port = this.port || 'PORT';
          return `Your ${this.selectedTunnelName} tunnel listens on localhost:${port}`;
        },

        // Debounce timer
        _debounce: null,

        // Computed API key (format: o3=opus-4.5,o3-mini=sonnet-4.5:sk-ant-xxx sk-xxx)
        get apiKey() {
          const keys = [];
          const claudeMappings = new Map();

          for (const route of this.routes) {
            if (!route.cursor || !route.claude) continue;
            const accountId = route.account || this.claude.activeAccount;
            if (!accountId) continue;
            const claudeAccount = this.claude.accounts[accountId];
            if (!claudeAccount || !claudeAccount.token) continue;

            if (!claudeMappings.has(accountId)) {
              claudeMappings.set(accountId, { token: claudeAccount.token, mappings: [] });
            }
            claudeMappings.get(accountId).mappings.push(`${route.cursor}=${route.claude}`);
          }

          for (const [, group] of claudeMappings) {
            if (!group.mappings.length) continue;
            keys.push(`${group.mappings.join(',')}:${group.token}`);
          }

          const chatgptAccount = this.chatgpt.activeAccount ? this.chatgpt.accounts[this.chatgpt.activeAccount] : null;
          if (chatgptAccount && chatgptAccount.token) {
            const chatgptKey = chatgptAccount.accountId
              ? `${chatgptAccount.token}#${chatgptAccount.accountId}`
              : chatgptAccount.token;
            keys.push(chatgptKey);
          } else if (!keys.length) {
            const claudeAccount = this.claude.activeAccount ? this.claude.accounts[this.claude.activeAccount] : null;
            if (claudeAccount && claudeAccount.token) {
              keys.push(claudeAccount.token);
            }
          }

          return keys.join(' ');
        },

        // Update target app and URL query param without reload
        setTargetApp(app) {
          if (this.targetApp === app) {
            this.targetApp = '';
            const url = new URL(window.location);
            url.searchParams.delete('to');
            window.history.pushState({}, '', url);
          } else {
            this.targetApp = app;
            const url = new URL(window.location);
            url.searchParams.set('to', app);
            window.history.pushState({}, '', url);
          }
        },

        // Initialize
        async init() {
          // Migration: Clear old localStorage keys (require re-login)
          if (localStorage.getItem('claude_token') || localStorage.getItem('chatgpt_token') || localStorage.getItem('chatgpt_account_id')) {
            localStorage.removeItem('claude_token');
            localStorage.removeItem('chatgpt_token');
            localStorage.removeItem('chatgpt_account_id');
            console.log('[Migration] Cleared old tokens - please re-login');
          }

          // Load Claude accounts from localStorage
          const savedClaudeAccounts = localStorage.getItem('claude_accounts');
          if (savedClaudeAccounts) {
            try {
              this.claude.accounts = JSON.parse(savedClaudeAccounts);
            } catch (e) {
              console.error('Failed to parse Claude accounts:', e);
            }
          }
          const savedClaudeActive = localStorage.getItem('claude_active_account');
          if (savedClaudeActive && this.claude.accounts[savedClaudeActive]) {
            this.claude.activeAccount = savedClaudeActive;
            this.claude.connected = true;
          }

          // Load ChatGPT accounts from localStorage
          const savedChatGPTAccounts = localStorage.getItem('chatgpt_accounts');
          if (savedChatGPTAccounts) {
            try {
              this.chatgpt.accounts = JSON.parse(savedChatGPTAccounts);
            } catch (e) {
              console.error('Failed to parse ChatGPT accounts:', e);
            }
          }
          const savedChatGPTActive = localStorage.getItem('chatgpt_active_account');
          if (savedChatGPTActive && this.chatgpt.accounts[savedChatGPTActive]) {
            this.chatgpt.activeAccount = savedChatGPTActive;
            this.chatgpt.connected = true;
          }

          try {
            const res = await fetch('/api/config');
            const config = await res.json();
            this.publicUrl = config.publicUrl;
            this.port = config.port;
          } catch (e) {
            console.error('Failed to fetch config:', e);
          }

          // Detect OAuth flow from query params
          const params = new URLSearchParams(window.location.search);
          if (params.get('oauth_flow') === '1') {
            this.oauth.active = true;
            this.oauth.pendingId = params.get('pending_id');
            this.oauth.clientId = params.get('client_id');
            this.oauth.state = params.get('state');
            console.log('[OAuth] Flow detected, pendingId:', this.oauth.pendingId);
          }
        },

        // Claude code input handler (1s debounce)
        claudeCodeInput() {
          clearTimeout(this._debounce);
          this._debounce = setTimeout(() => {
            if (this.claude.code.includes('#')) {
              this.submitClaudeCode();
            }
          }, 1000);
        },

        // Submit Claude code
        async submitClaudeCode() {
          this.claude.loading = true;
          this.claude.error = null;
          const hadClaudeAccounts = Object.keys(this.claude.accounts).length > 0;
          try {
            const res = await fetch('/auth/claude/complete', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ code: this.claude.code })
            });
            const data = await res.json();
            if (data.success) {
              const email = data.email || `account_${Date.now()}`;

              // Store account
              this.claude.accounts[email] = {
                token: data.accessToken,
                refreshToken: data.refreshToken,
                email: email,
                displayName: email
              };
              this.claude.activeAccount = email;
              this.claude.connected = true;
              this.claude.code = '';
              this.claude.showInput = false;

              if (!hadClaudeAccounts) {
                this.ensureDefaultClaudeRoutes();
              }

              // Save to localStorage
              localStorage.setItem('claude_accounts', JSON.stringify(this.claude.accounts));
              localStorage.setItem('claude_active_account', email);

              // If in OAuth flow, complete it
              if (this.oauth.active) {
                await this.completeOAuthFlow();
              }
            } else {
              this.claude.error = data.error;
            }
          } catch (e) {
            this.claude.error = 'Failed to connect: ' + e.message;
          } finally {
            this.claude.loading = false;
          }
        },

        ensureDefaultClaudeRoutes() {
          const hasRoutes = this.routes.some(route => route.cursor && route.claude);
          if (hasRoutes) return;
          this.routes = [
            { cursor: 'o3', claude: 'opus-4.5', account: this.claude.activeAccount || '' },
            { cursor: 'o3-mini', claude: 'sonnet-4.5', account: this.claude.activeAccount || '' }
          ];
        },

        // Disconnect Claude and clear active account
        disconnectClaude() {
          if (this.claude.activeAccount) {
            // Remove active account
            delete this.claude.accounts[this.claude.activeAccount];
            this.claude.activeAccount = null;

            // If other accounts exist, switch to first one
            const remainingAccounts = Object.keys(this.claude.accounts);
            if (remainingAccounts.length > 0) {
              this.claude.activeAccount = remainingAccounts[0];
              this.claude.connected = true;
            } else {
              this.claude.connected = false;
            }

            // Update localStorage
            localStorage.setItem('claude_accounts', JSON.stringify(this.claude.accounts));
            if (this.claude.activeAccount) {
              localStorage.setItem('claude_active_account', this.claude.activeAccount);
            } else {
              localStorage.removeItem('claude_active_account');
            }
          }

          this.claude.code = '';
          this.claude.showInput = false;
          this.claude.error = null;
        },

        // Start ChatGPT device flow
        async startChatGPT() {
          this.chatgpt.error = null;
          try {
            const res = await fetch('/auth/openai/start', { method: 'POST' });
            const data = await res.json();
            if (data.error) {
              this.chatgpt.error = data.error;
              return;
            }
            this.chatgpt.deviceId = data.userCode;
            this.chatgpt.sessionId = data.sessionId;
            this.pollChatGPT();
          } catch (e) {
            this.chatgpt.error = 'Failed to start: ' + e.message;
          }
        },

        // Poll ChatGPT for authorization
        async pollChatGPT() {
          this.chatgpt.polling = true;
          try {
            const res = await fetch('/auth/openai/poll', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ sessionId: this.chatgpt.sessionId })
            });
            const data = await res.json();
            if (data.status === 'success') {
              if (!data.accountId) {
                this.chatgpt.error = 'Missing ChatGPT account id. Please re-login.';
                this.chatgpt.polling = false;
                return;
              }

              const accountId = data.accountId;
              const email = data.email;
              const displayName = email || accountId;

              // Store account
              this.chatgpt.accounts[accountId] = {
                token: data.accessToken,
                accountId: accountId,
                email: email,
                displayName: displayName
              };
              this.chatgpt.activeAccount = accountId;
              this.chatgpt.connected = true;
              this.chatgpt.polling = false;
              this.chatgpt.showInput = false;

              // Save to localStorage
              localStorage.setItem('chatgpt_accounts', JSON.stringify(this.chatgpt.accounts));
              localStorage.setItem('chatgpt_active_account', accountId);

              // If in OAuth flow, complete it
              if (this.oauth.active) {
                await this.completeOAuthFlow();
              }
            } else if (data.status === 'pending') {
              setTimeout(() => this.pollChatGPT(), 5000);
            } else {
              this.chatgpt.error = data.error || 'Authorization failed';
              this.chatgpt.polling = false;
            }
          } catch (e) {
            this.chatgpt.error = 'Polling failed: ' + e.message;
            this.chatgpt.polling = false;
          }
        },

        // Disconnect ChatGPT and clear active account
        disconnectChatGPT() {
          if (this.chatgpt.activeAccount) {
            // Remove active account
            delete this.chatgpt.accounts[this.chatgpt.activeAccount];
            this.chatgpt.activeAccount = null;

            // If other accounts exist, switch to first one
            const remainingAccounts = Object.keys(this.chatgpt.accounts);
            if (remainingAccounts.length > 0) {
              this.chatgpt.activeAccount = remainingAccounts[0];
              this.chatgpt.connected = true;
            } else {
              this.chatgpt.connected = false;
            }

            // Update localStorage
            localStorage.setItem('chatgpt_accounts', JSON.stringify(this.chatgpt.accounts));
            if (this.chatgpt.activeAccount) {
              localStorage.setItem('chatgpt_active_account', this.chatgpt.activeAccount);
            } else {
              localStorage.removeItem('chatgpt_active_account');
            }
          }

          this.chatgpt.deviceId = '';
          this.chatgpt.sessionId = null;
          this.chatgpt.polling = false;
          this.chatgpt.showInput = false;
          this.chatgpt.error = null;
        },

        // Fetch tunnel providers
        async fetchTunnelProviders() {
          this.tunnel.loading = true;
          this.tunnel.error = null;
          try {
            const res = await fetch('/api/tunnels', {
              headers: { 'Accept': 'application/json' }
            });
            const data = await res.json();
            this.tunnel.providers = data.providers || [];
            this.tunnel.status = data.status || { active: false };
            const available = this.tunnel.providers.filter(p => p.available);
            if (available.length > 0 && !this.tunnel.selectedProvider) {
              this.tunnel.selectedProvider = data.status?.providerId || available[0].id;
            }
          } catch (e) {
            this.tunnel.error = 'Failed to load providers: ' + e.message;
          } finally {
            this.tunnel.loading = false;
          }
        },

        // Start tunnel
        async startTunnel() {
          if (!this.tunnel.selectedProvider) return;
          this.tunnel.starting = true;
          this.tunnel.error = null;
          const rawDomain = (this.tunnel.customDomain || '').trim();
          const namedUrl = rawDomain
            ? rawDomain.replace(/^https?:\/\//, '').split('/')[0]
            : undefined;
          try {
            const res = await fetch(`/api/tunnels/${this.tunnel.selectedProvider}/start`, {
              method: 'POST',
              headers: { 'Accept': 'application/json', 'Content-Type': 'application/json' },
              body: JSON.stringify({ namedUrl })
            });
            const data = await res.json();
            if (data.success) {
              this.tunnel.status = data.status;
              this.tunnel.customDomain = '';
            } else {
              this.tunnel.error = data.error;
            }
          } catch (e) {
            this.tunnel.error = 'Failed to start tunnel: ' + e.message;
          } finally {
            this.tunnel.starting = false;
          }
        },

        // Stop tunnel
        async stopTunnel() {
          this.tunnel.error = null;
          try {
            await fetch('/api/tunnels/stop', {
              method: 'POST',
              headers: { 'Accept': 'application/json' }
            });
            this.tunnel.status = { active: false, publicUrl: null };
          } catch (e) {
            this.tunnel.error = 'Failed to stop tunnel: ' + e.message;
          }
        },

        // Complete OAuth flow (called after successful provider auth)
        async completeOAuthFlow() {
          if (!this.oauth.active || !this.oauth.pendingId) {
            console.log('[OAuth] No active OAuth flow to complete');
            return;
          }

          this.oauth.completing = true;
          this.oauth.error = null;

          try {
            // Build providers object with current credentials
            const providers = {};

            if (this.claude.connected && this.claude.activeAccount) {
              const account = this.claude.accounts[this.claude.activeAccount];
              if (account) {
                providers.claude = {
                  access_token: account.token,
                  refresh_token: account.refreshToken
                };
              }
            }

            if (this.chatgpt.connected && this.chatgpt.activeAccount) {
              const account = this.chatgpt.accounts[this.chatgpt.activeAccount];
              if (account) {
                providers.chatgpt = {
                  access_token: account.token,
                  account_id: account.accountId
                };
              }
            }

            if (!providers.claude && !providers.chatgpt) {
              this.oauth.error = 'Please authenticate with at least one provider';
              return;
            }

            // Get user ID (email or account ID)
            const userId = this.claude.activeAccount || this.chatgpt.activeAccount || 'anonymous';

            // Request authorization code
            const res = await fetch('/oauth/code', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                pending_id: this.oauth.pendingId,
                user_id: userId,
                providers
              })
            });

            const data = await res.json();

            if (data.success && data.redirect_uri && data.code) {
              // Build redirect URL with authorization code
              const redirectUrl = new URL(data.redirect_uri);
              redirectUrl.searchParams.set('code', data.code);
              if (data.state) {
                redirectUrl.searchParams.set('state', data.state);
              }

              console.log('[OAuth] Redirecting to:', redirectUrl.toString());
              window.location.href = redirectUrl.toString();
            } else {
              this.oauth.error = data.error || 'Failed to complete authorization';
            }
          } catch (e) {
            this.oauth.error = 'Failed to complete OAuth: ' + e.message;
          } finally {
            this.oauth.completing = false;
          }
        }
      };
    }
  </script>
</body>
</html>
